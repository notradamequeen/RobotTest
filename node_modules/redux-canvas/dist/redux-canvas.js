(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ReduxThunk"] = factory();
	else
		root["ReduxThunk"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	var canvas = function canvas(state) {
		if (state === null || typeof state !== "object") {
			throw new Error("canvasMiddleware: state is not an object");
		}
		return function (next) {
			var frameId = null;
			var dispatch = state.dispatch;
			var getState = state.getState;

			var contexts = new Map();
			var animations = new Map();
			var paintOnce = [];
			// requestAnimationFrame fallback
			var raf = function raf(f) {
				return setTimeout(f, 20);
			};
			if (typeof window !== "undefined" && window.requestAnimationFrame) {
				raf = window.requestAnimationFrame;
			}
			function loop(t) {
				if (animations.size > 0) {
					frameId = raf(loop);
				} else {
					frameId = null;
				}
				while (paintOnce.length > 0) {
					var paint = paintOnce.shift();
					paint(t, contexts, getState, dispatch);
				}
				for (var _iterator = animations.values(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
					var _ref;

					if (_isArray) {
						if (_i >= _iterator.length) break;
						_ref = _iterator[_i++];
					} else {
						_i = _iterator.next();
						if (_i.done) break;
						_ref = _i.value;
					}

					var animate = _ref;

					animate(t, contexts, getState, dispatch);
				}
			}

			return function (action) {
				var result = next(action);
				var m = action.meta || action.action && action.action.meta;
				if (m) {
					var keys = Object.keys(m);
					for (var i = 0; i < keys.length; i++) {
						switch (keys[i]) {
							case "registerContext":
								if (m.registerContext.ctx === null || typeof m.registerContext.ctx !== "object" || typeof m.registerContext.name !== "string") {
									throw new Error("\"registerContext\" expects ctx \n\t\t\t\t\t\t\t                to be an object and name to be \n\t\t\t\t\t\t\t                a string. Got: " + m);
								}
								contexts.set(m.registerContext.name, m.registerContext.ctx);
								break;
							case "unregisterContext":
								if (typeof m.unregisterContext !== "string") {
									throw new Error("unregisterContext expects a string \n\t\t\t\t\t\t\t                 Got: " + m);
								}
								contexts["delete"](m.unregisterContext);
								break;
							case "paintOnce":
								if (typeof m.paintOnce !== "function") {
									throw new Error("paintOnce expects a function");
								}
								paintOnce.push(m.paintOnce);
								break;
							case "startAnim":
								if (typeof m.startAnim.anim !== "function" || typeof m.startAnim.name !== "string") {
									throw new Error("startAnim expects anim to be \n\t\t\t\t\t\t\t                 a function and name to be a \n\t\t\t\t\t\t\t                 string. Got " + m);
								}
								animations.set(m.startAnim.name, m.startAnim.anim);
								break;
							case "stopAnim":
								if (typeof m.stopAnim !== "string") {
									throw new Error("stopAnim expects a string.\n\t\t\t\t\t\t\t                 Got: " + m);
								}
								animations["delete"](m.stopAnim);
								break;
							default:
								continue;
						}
					}
				}
				if (!frameId && (paintOnce.length > 0 || animations.size > 0)) {
					frameId = raf(loop);
				}
				return result;
			};
		};
	};
	exports["default"] = canvas;

/***/ }
/******/ ])
});
;